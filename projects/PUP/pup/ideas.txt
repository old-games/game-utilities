13-09-2010

	Реализовал упаковщик/распаковщик для Duke Nukem 3D (grp.c).

	Он также должен быть пригоден для следующих игр:
		* Blood
		* Shadow Warrior
		* Redneck Rampage

14-09-2010

	Реализовал упаковщики/распаковщики для
	Dune 2: The Building of Dynasty (pak.c) и
	Star Wars: Dark Forces (gob.c).

	Последний должен быть пригоден также для игры Outlaws.
	
14-09-2010

	Реализовать проверку допустимости имён ресурсов. Для grp.c,
	pak.c и gob.c - это обычные досовские имена: до 8 символов
	в имени, точка, до трёх символов расширения, все в верхнем
	регистре. Допустимы латинские буквы, цифры, знаки минус,
	подчёркивание.

	Реализовать проверку на перекрытие ресурсов.

	Реализовать возврат статуса успеха/неудачи там, где успех
	не гарантирован.

15-09-2010
	Реализован распаковщик/упаковщик для Quake (pack.c).

	Он должен также работать с ресурсами других игр:
		* Quake 2,
		* Heretic 2,
		* Half-Life,
		 Counter strike,
		 Opposing force,
		* Soldier of fortune,
		* MDK 2.

Разработана новая концепция программ распаковки/упаковки.

План упаковки:
1. Получаем список имён файлов, которые нужно запаковать,
2. Из имён файлов получаем имена ресурсов,

3. Считаем размер заголовка вместе с каталогом (если каталог следует непосредственно за заголовком),
4. Записываем все ресурсы. На этом этапе обязательно нужно заполнить недостающие нужные элементы каталога:
 смещение ресурса, если оно нужно,
 размер ресурса, если он нужен,
 размер ресурса в сжатом виде, если нужен и если используется сжатие,
 тип ресурса и/или тип сжатия.
5. Записываем правильный заголовк файла и каталог, устанавливаем смещение на конец файла.

План распаковки:
1. Считываем каталог,
2. Заполняем недостающие поля каталога (можно делать на этапе 1),
3. Распаковка ресурсов или печать содержимого каталога или проверка целостности и непротиворечивости каталога.

typedef enum type_e
{
};

typedef struct resentry_s
{
	char *name;	// Имя ресурса
	char *filename;	// Имя файла на диске
	size_t size;	// Размер ресурса на диске
	size_t compressed; // Размер ресурса внутри файла-пачки
	size_t offset;	// Смещение ресурса
	restype_t type;	// Тип ресурса или алгоритм сжатия
} resentry_t;

typedef struct resdir_s
{
	size_t number;	// Количество ресурсов в каталоге
	resentry_t *dir; // Каталог ресурсов
} resdir_t;

/* Сканирует файловую систему, заполняя каталог ресурсов именами файлов.
Сканирование может быть рекурсивным, нерекурсивным, с сортировкой файлов
по алфавиту или без неё, с добавлением маркеров начала и конца очередного
каталога или без маркеров.*/
bool_t xxx_get_list(resdir_t *dir, const char *path);

/* Заполняет каталог именами ресурсов, правильных для данного формата xxx.*/
bool_t xxx_fill_names(resdir_t *dir);

/* Считает размер начальной части файла (заголовок и каталог, если каталог не
в конце файла) для формата xxx.*/
bool_t xxx_get_header_size(resdir_t *dir, unsigned long *header_size);

/* Пакует файлы начиная с указанного смещения offset. В процессе паковки
файлов заполняются остальные поля - смещение файла, его исходный размер,
сжатый размер и тип. Возвращает смещение offset, соответсующее байту,
следующему за последним упакованным ресурсом. */
bool_t xxx_pack_files(FILE *file, resdir_t *dir, const char *basepath, unsigned long *offset);

/* Записывает заголовок и каталог ресурсов. Если каталог ресурсов должен
находиться после ресурсов, то он записывается по смещению offset.*/
bool_t xxx_write_dir(FILE *file, resdir_t *dir, unsigned long offset);

/* Считывание каталога ресурсов и заполнение недостающих полей. */
bool_t xxx_read_dir(FILE *file, resdir_t *dir);

/* Извлечение ресурсов в отдельные файлы. */
bool_t xxx_unpack_files(FILE *file, resdir_t *dir, const char *basepath);

/* Печать содержимого каталога ресурсов. */
void xxx_print(resdir_t *dir);

	Написан новый вариант grp.c, использующий новую типовую схему
	паковки/распаковки.

16-09-2010

	Написана функция is_dos_filename, проверяющая, является ли
	строка именем файла DOS (проверка схемы 8.3 и допустимых символов).

	Спроектировал новую типовую схему паковки/распаковки:

Упаковка:

/* Сканирует каталог src_path в поисках файлов для упаковки,
заполняет имена ресурсов, считает размер заголовка с каталогом
(если каталог должен располагаться в начале файла), устанавливает
текущий указатель файла file на ту позицию, откуда можно начать
записывать ресурсы. */
bool_t xxx_prepare_dir(FILE *file, resdir_t *dir, const char *src_path);

/* Указатель в файле должен указывать на первый байт, относящийся
 к какому-либо ресурсу.
Пакует файлы, перечисленные в каталоге dir и находящиеся в каталоге
файловой системы src_path. Попутно заполняет смещение каждого ресурса,
его размер, сжатый размер, тип ресурса или способ сжатия.*/
bool_t xxx_pack_files(FILE *file, resdir_t *dir, const char *src_path);

/* Указатель в файле должен указывать на следующий байт после всех ресурсов.
 Переходит в начало файла ресурсов, записывает заголовок,
 заполненный готовый каталог ресурсов за заголовком или записанными данными.*/
bool_t xxx_write_dir(FILE *file, resdir_t *dir);

Распаковка:

/* Читает каталог из файла ресурсов, заполняет имена файлов, которые
будут использоваться при извлечении ресурсов в файлы. */
bool_t xxx_read_dir(FILE *file, resdir_t *dir);

/* Печать каталога ресурсов, заполненного функцией xxx_read_fir. */
void xxx_print_dir(resdir_t *dir);

/* Извлечение всех ресурсов из файла с ресурсами. */
bool_t xxx_unpack_files(FILE *file, resdir_t *dir, const char *dst_path);

	Переписана программа grp.c под новую типовую схему упаковки/распаковки.
	Программа получилась очень компактной, вся логика работы программы
	просматривается легко. Это, пожалуй, самая оптимальная схема
	упаковки/распаковки. В дальнейшем буду использовать именно её.

	Дальнейший план - скомпоновать упаковщики/распаковщики
		pak.c
		gob.c
		pack.c
	под новую схему упаковки/распаковки.

	Потом можно приступить к реализации упаковщиков/распаковщиков
		vpp.c (Red Faction,
			нужно будет написать vpp_unpack_files),
		viv.c (NFS)
		dpk4.c (Starmageddon, без распаковки сжатых ресурсов)
		pack2.c (Daikatana,
			 для начала без распаковки сжатых ресурсов)
		wad2.c (Quake, Half-Life, без конвертации изобажений)
		wad.c (Doom, Heretic, Hexen, Strife,
			без конвертации изображений)

17-09-2010

	Реализовал распаковщик/паковщик pak.c по новой схеме
	упаковки/распаковки.

	Реализовал распаковщик/паковщик gob.c по новой схеме
	упаковки/распаковки. Имена файлов в gob - это не DOS-имена,
	у некоторых файлов длина собственно имени достигает
	9 символов. Сделал проверку лишь полную длину имени файла
	с расширением - она не должна быть больше 12 символов.

	Реализовал распаковщик/паковщик pack.c по новой схеме
	упаковки/распаковки. Добавил проверку по длине имени
	файла - общая длина вместе с каталогами и расширением
	не должна превышать 56 символов.

18-09-2010

	Реализовал распаковщик/паковщик vpp.c.

	Функцию dir_pack_files можно переписать с использованием
	выравнивания файлов по размеру страницы. Эту обобщённую
	функцию можно использовать во всех паковщиках.

	Также можно объединить функции dir_get_list и dir_get_rlist.
	Использовать обобщённую функцию с указанием булевого параметра,
	указывающего работать ли в рекурсивном варианте или в
	нерекурсивном.

	Можно объединить функции mkpath и dir_make_dirs, добавив
	параметр булевого типа, который будет указывать, работать
	ли в рекурсивном режиме или нет.

	Реализовать проверку перекрытия ресурсов.

19/20-09-2010

	Переписал функцию dir_pack_files, добавив функцияю выравнивания
	размера ресурса в файле до кратного указанному.

	Переписал функцию dir_get_list, добавив булевый параметр - 
	поддержка рекурсии. В случае если рекурсия не поддерживается, но
	обнаружен подкаталог, функция завершается с ошибкой.

	От объединения mkpath и dir_make_dirs отказался, т.к. получившаяся
	функция стала бы зависеть от структуры resdir_t, даже если она не
	нужна при нерекурсивном вызове. В таком случае функцию mkpath
	всё равно пришлось бы оставить для проектов, не использующих
	resdir_t, а это бы только усложнило и увеличило бы проект в размерах.

21-09-2010

	Оформил исходники копрессора и декомпрессора из старой программы
	pack2/v2 в виде модуля pack2_lz.c и pack2_lz.h

	Под вечер написал pack2.c. Программа вроде-бы нормально распаковывала
	ресурсы с диска, но запакованные самой собой ресурсы распаковывала
	неправильно - совпадала какая-то начальная часть распакованного
	файла, а дальше шёл мусор. Выяснить в чём дело не удалось.

22-09-2010

	Во второй половине дня обнаружил ошибку в функции декомпрессии. Она
	неожиданно завершала работу, не завершив распаковку. Виной этому
	было неправильное условие завершения работы. После исправления
	несколько раз распакованные и запакованные файлы остаются идентичными,
	что говорит об отсутствии явных ошибок в алгоритме упаковки/распаковки.

	На этот раз меня заинтересовало другое обстоятельство. Моя программа,
	в подавляющем большинстве случаев сжимая ресурсы лучше, чем программа
	разработчиков игры, создавала файл большего размера. Эту проблему я
	за сегодняшний день так и не решил. Все проверки показывают, что
	моя программа сжала эффективнее в сумме на 23 мегабайта, лишь в
	отдельных 90 случаях показав суммарное отставание в 251 байт. Но тем
	не менее результирующий файл, созданный моей программой, оказался
	примерно на 40 килобайт больше оригинального файла.
	
23-09-2010

	Посчитал размер исходного файла через сумму размеров сжатых ресурсов.
	Она оказалась больше размера исходного файла! Заподозрив неладное,
	реализовал-таки наконец проверку перекрытия ресурсов. В исходном файле
	есть перекрытия ресурсов - одинаковые по содержимому ресурсы с разными
	именами не добавляются повторно, они ссылаются на уже имеющиеся в
	файле данные, так что два ресурса ссылаются на один и тот же блок.

	Теперь хочу реализовать кроме проверки перекрытия ресурсов ещё и поиск
	ресурсов-дубликатов, которые ссылаются на один и тот же блок в файле.

	Ещё хочу реализовать поиск дубликатов при добавлении очередного файла
	и всё-таки утереть нос паковщику, который создал оригинальный файл, 
	из чисто спортиновго интереса. Ну и вообще будет полезно уметь создавать
	компактные файлы, там где это возможно (форматы grp, pak и vpp сделать
	это не позволяют).

	Что там ещё остаётся в планах?
		wad2/wad3 (Quake, Half Life)
		dpk4 (Starmageddon)
		viv (NFS)
		wad (Doom)


26-09-2010

	Добавил массу проверок и диагностических сообщений в модуль binrw.c

	Реализовал модуль wad23.c для работы с WAD2 и WAD3-файлами.

28-09-2010

	Добавил модуль viv.c для работы с VIV-файлами NFS. Пока не проверял.

	Переделал модули grp.c, gob.c, pak.c, pack.c, pack2.c, wad23.c в плагины,
	написал единую программу, работающую с плагинами. В каждом из плагинов
	реализована функция "узнавания" своего формата. Функции узнавания,
	перебираемые в цикле, позволяют реализовать функцию автоопределения
	формата файла.

	Добавил к программе модули vpp.c, viv.c. Написал новую функцию main с
	новой логикой обработки опций и новыми опциями.

29-09-2010

	Сделал наметки для программы piconv: написал функцию задания формата
	хранения цвета по маске каждого из компонентов, функцию преобразования
	цвета из одного формата в другой. Ещё требуется отладка на случай
	если компонент не используется.

	Написал функции s_pathname и s_nameext в модуле binrw.c. Задействовал
	новую функцию в main.c программы puptool.

	В планах, как и прежде:
		IWAD, PWAD - Doom & Co
		DPK4 - Starmageddon
	К планам прибавились:
		RES - Comanche 3
		RFF - Blood
		DAT - Fallout
		DAT - Fallout 2

30-09-2010

	Добавил модуль rff.c. Распаковка и упаковка происходят отлично, однако
	игра использует поле entry.unknown2 в качестве идентификаторов ресурсов.
	Многие ресурсы игра ищет не по имени, а по идентификатору. Из-за этого
	простая упаковка файлов не даёт нужного эффекта. Чтобы игра заработала,
	нужно восстанавливать ещё и значение этого поля. Для этого нужно
	при экспорте ресурсов создавать также один специальный файл с именами
	ресурсов и их номерами, а при импорте искать этот файл и считывать из
	него идентификаторы ресурсов.

01-09-2010

	Разработал новую концепцию библиотеки resdir.c, теперь она называется
	restable.c. В каждом плагине необходимо добавить две простые функции:
	get_resname и get_filename, которые будут преобразовывать имя файла в
	имя ресурса и возвращать его. Если получающееся имя ресурся не является
	правильным для данного формата, то вместо имени ресурса возвращается
	NULL. То же самое и для get_filename.

	void get_resname(char **resname, const char *filename);
	void get_filename(char **filename, const char *resname);

	При необходимости эти функции могут анализировать или заполнять
	дополнительные поля, например как в модуле wad23.c.

	Следует также воспользоваться функцией ferror для анализа всех ошибок
	чтения-записи одной логически целостной структуры: заголовка, записи
	в каталоге ресурсов или всего каталога.

	Для чтения чисел из файла нужно переписать функции freadXe и fwriteXe
	так, чтобы они не анализировали ошибки чтения/записи. Все ошибки
	чтения/записи должны анализировать вышестоящие функции с помощью
	функции ferror.

	При чтении/записи структур следует пользоваться группировкой
	полей в структуры, но поля читать по одному, с помощью спец. функций
	чтения/записи полей различных типов.

	Все эти изменения позволят сделать программу более компактной и
	более концептуально целостной.

02-09-2010

	Портировал на библиотеку restable и новую плагинную систему плагины
	grp и gob.

	Следующее изменение в плагинной системе, которое можно сделать -
	это вынести в плагин функции fill_resname и fill_filename. fill_resname
	будет вызываться для каждого их файлов в таблице сразу после вызова
	функции fill_entries. Эта функция будет не только конвертировать
	имя файла в имя ресурса, но и проверять правильность имени ресурса для
	данного файла-пачки. fill_filenames будет вызываться для каждого
	ресурса в таблице сразу после функции read_dir.

	Переделал плагинную систему с введением функций fill_name и
	fill_filename, а также поля page. Портировал модули grp, gob и pak на
	новую систему плагинов.

Сравнение размеров новой и старой программ:
Новая:
  991 binrw.c
   80 binrw.h
  325 restable.c
   69 restable.h
  134 grp.c
   21 grp.h
  159 gob.c
   21 gob.h
  158 pak.c
   21 pak.h
  373 main.c
 2352 итого
Старая:
  991 binrw.c
   79 binrw.h
  494 resdir.c
   42 resdir.h
  160 grp.c
   16 grp.h
  180 gob.c
   16 gob.h
  175 pak.c
   16 pak.h
  457 main.c
 2626 итого

Сравнение модулей main не совсем честное, поскольку в старой программе больше
таблица плагинов.

	В дальнейшем в плагинную систему можно добавить дополнительные
	функции для сохранения дополнительной информации о файлах в текстовый
	файл и для восстановления этой информации из текстового файла.

	Этот функционал будет использоваться для распаковки/упаковки файлов
	формата rff и wad2/wad3. 

03-10-2010

	Портировал на новую систему плагинов и restable модуль viv.c, заодно исправив его (добавил
	выравнивание ресурсов по смещению, кратному 4, исправил подсчёт размера каталога).

04-10-2010

	Переделать функции rt_realloc и rt_add_filename в функции rt_set_number,
	rt_add_entry:

/* В случае успеха возвращает TRUE, устанавливает rt->number = number и
очищает все поля всех элементов rt->entries */
	bool_t rt_set_number(restable_t *rt, uint32_t number);

/* В случае успеха возвращает TRUE, увеличивает rt->number и очищает добавленную
запись. Последняя добавленная запись - пустая. */
	bool_t rt_add_entry(restable_t *rt);

	Портировал на новую систему плагинов и restable модуль vpp.c.

	Можно также унифицировать проверку допустимости имени ресурса. Проверку
	имён файлов DOS можно оставить, а остальные проверки должны сводиться
	к двум простым правилам: проверка максимальной длины имени ресурса и
	проверка принадлежности каждого символа множеству допустимых для данного
	формата символов.

	Портировал на новую систему плагинов и restable модуль pack.c.

	Портировал на новую систему плагинов и restable модуль pack2.c.

	Новая идея: вместо больших и похожих друг на друга функций
	xxx_read_resources и xxx_write_resources написать функции поменьше:
	xxx_read_resource и xxx_write_resource, а цикл по извлечению/добавлению
	ресурсов вынести в функции pack и unpack.

	bool_t rt_read_resource(resentry_t *re);
	bool_t rt_write_resource(resentry_t *re, uint32_t page);

	Такое решение позволит в дальнейшем выполнять, например, выборочное
	извлечение ресурсов.

05-10-2010

	Портировал wad23.c на новую систему плагинов и restable.c.

	Переписал строковые функции из модуля binrw.c так, что они теперь
	дополнительно сообщают об ошибке, возвращая FALSE.

	Добавил функции strnlower и strnupper в модуль binrw.c.

	Переписал программу так, что она теперь использует функции
	rt_set_number и rt_add_entry для добавления элементов в таблицу
	ресурсов.

06-10-2010

	Написал функции freadf и fwritef, переписал все модули на использование
	новых функций. Программа уменьшилась с 38 килобайт до 32. Предполагаю,
	что уменьшение обусловлено резким сокращением количества и объёма
	диагностических сообщений.

	Объём проекта в строках наоборот увеличился (удивительно).

07-10-2010

	Написал модуль res.c для RES-файла игры Comanche 3. Замучился. Нужно
	проверить на игре.

	Шифрование имён - это фигня, т.к. с ней я разобрался ещё тогда, когда
	я играл в игру (это было 09-02-2003).

	Одна из заморочек файла ресурсов - это фиктивный ресурс с именем
	\xD2OOT, поле смещения которого равно размеру заголовка файла с
	каталогом, а в поле размера его указан 0.

	Вторая заморочка заключается в том, что перед каждым ресурсом записана
	информация о следующем ресурсе, но в последнем ресурсе записана
	информация не о фиктивном ресурсе, а о следующем за ним настоящем.

	Третье подозрительное место - это 16 нулевых байт, которые зачем-то
	добавлены в конце файла.

	Четвёртая заморочка заключается в том, что ресурсы C3.SAV и SETUP.MDM
	в RES-файле встречаются аж два раза. Они одинакового размера и идут
	друг за другом.

	По планам остаётся реализовать следующие модули:
		DPK4 - Starmageddon
		IWAD, PWAD - Doom & Co
		RFFP, RFFC - Blood (портировать на restable и добавить
			сохранение и восстановление идентификаторов и типов
			ресурсов)
		DAT - Fallout
		DAT - Fallout 2
		LABN - Outlaws

	Протестировал модуль res.c, исправив попутно кучу недоработок.
	Comanche 3 с собранным мной файлом ресурсов запустился и заработал.

08-10-2010

	Написал модуль dpk4.c и добавил поддержку декомпрессии и компрессии
	с помощью библиотеки zlib. К сожалению извлекаются не все ресурсы,
	а после сжатия размер файла по сравнению с исходным файлом из
	дистрибутива игры возрастает аж в 2 раза. Смысла в сжатии нет?

	Просмотрел информацию о файле, созданном моей программой - ни один
	ресурс не был сжат. Добавил диагностику ошибок сжатия и нашёл
	ошибку в расчёте места под сжимаемые данные. Исправил ошибку -
	теперь сжатый файл по размеру практически равен исходному.

	Просмотрел информацию о неправильно расжатых файлах - их сжатый
	размер оказался равен несжатому. Убрал разжатие ресурсов, разжатый
	размер которых равен сжатому - сделал так, чтобы они извлекались
	в исходном виде. Разжатие прошло без ошибок. Модуль dpk4.c
	полностью отлажен.

	Игра запустилась с созданным моей программой файлом.

10-10-2010

	Пытался реализовать модуль dat.c для распаковки и упаковки
	DAT-файлов игры Fallout. Структура файла не тривиальна, а алгоритм
	сжатия LZSS, применённый в DAT-файлах довольно редок.

11-10-2010

	Добавил в форматную строку поддержку записи и чтения строк "sn".

	При этом длина читаемой строки определяется по числу, указатель
	на которое идёт прямо за указателем указателя на строку.
	Длина записываемой строки берётся из числа, следующему за
	указателем на записываемую строку.

	По этой же системе добавил поддержку форматных строк "cn" и "zn".

	Добавил модуль dat2.c, поддерживающий DAT-файлы Fallout 2.
	Проверка показала, что Fallout 2 не замечает подмены файла.

	Портировал модуль rff.c на restable и новую систему модулей.

12-10-2010

	Придумал метод, с помощью которого можно исключать дубликаты
	файлов. В resentry_t можно добавить дополнительное поле
	int32_t copyof, в котором будет записываться номер файла,
	с которым совпадает содержимое данного файла. Для файлов,
	не имеющих дубликатов или исходного файла из группы совпадающих
	в это поле помещается индекс -1.

	После заполнения структуры restable_t информацией о структуре
	каталогов можно пройтись по всем файлам и сравнить по содержимому
	файлы одинакового размера. Для файлов, у которых найдены дубликаты
	в это поле можно записать номер первого файла, с которым совпадают
	последующие. При записи ресурсов функцией add_resources будет
	приниматься во внимание это поле и файлы, поле copyof у которых
	больше нуля добавляться не будут, но поля offset, size, compression
	и compressed будут заполняться копиями данных полей из файла-оригинала.

	Также задумал новую систематическую структуру для DAT-файлов.
	Немного громоздко, зато понятно. Структуры, которые будут
	использованы внутри модуля можно будет использовать независимо от
	структуры restable_t в отдельной программе, если таковую понадобится
	написать.

	Основная загвоздка в поддержке формата DAT-файлов Fallout по-прежнему
	заключается в написании декомпрессора и компрессора формата LZSS.

	Скачал исходники f1undat, в которых есть функционал для распаковки
	ресурсов. Исходники декомпрессора, правда, большей частью
	на Assembler.

13-10-2010

	Нашёл ресурс с большим количеством примеров реализации компрессора
	lzss на C.

	Написал функцию rt_check_overlaps, которая ищет копии ресурсов
	и перекрывающиеся ресурсы. Во время работы функция заполняет
	новое поле resentry_t - поле copyof, в которое помещается номер
	ресурса, копией которого является данный ресурс. Если ресурс не
	является копией, то в это поле помещается -1.

	Проверка на файле pak1.pak из Daikatana показала, что функция
	справляется с возложенной на неё работой.

	Теперь можно написать функцию сравнения файлов и функцию поиска
	дубликатов файлов, которая аналогичным образом будет заполнять
	поле copyof каждой из записей. Потом можно дописать особое поведение
	в функции добавления ресурсов, чтобы она не добавляла дважды
	одно и то же содержимое разных ресурсов, а лишь добавляла ссылку
	на ранее добавленный ресурс-оригинал.

	Написал функционал объединения дубликатов файлов, прописал его во
	все модули, позволяющие объединенять ресурсы.

	Протестировал функцию на файле pak1.pak игры Daikatana. Превосходно,
	моя программа наконец-таки победила упаковщик Daikatana:
		Размер оригинального файла:	167129921
		Размер перепакованного файла:	164899416
	Общая экономия - около 3 мегабайт.

	Тестирование объединение дубликатов на примере файла data.dpk
	Starmageddon 2
		Оригинал:	288025136
		Перепакованный:	276083021
	Общая экономия - почти 12 мегабайт.


	Можно добавить в структуру plugin_t дополнительное поле - возможность
	объединять дубли ресурсов.

	Нужно вынести из функций *_add_resources подфункции *_add_resource,
	при этом выравнивание ресурсов и цикл по ресурсам будут вынесесны
	в головной модуль. То же самое можно сделать и с функциями
	*_extract_resources, то есть вынести из них подфункции *_add_resource,
	а цикл по ресурсам перенести в головной модуль.

	Можно добавить в головной модуль две дополнительные опции:
	--nocompress/--compress и --nomerge/--merge. Как вариант, можно
	сделать одну опцию --fast/--finish, которая будет отключать или
	включать сжатие ресурсов, если оно поддерживается этим форматом и
	слияние дубликатов, если слияние дубликатов возможно для этого
	формата.

14-10-2010

	Портировал программу на новую систему плагинов:
	вместо функций add_resources(restable_t *rt, uint32_t page)
		используется add_resource(restable_t *rt, uint32_t i),
	вместо функций extract_resources(restable_t *rt, uint32_t page)
		используется extract_resource(restable_t *rt, uint32_t i),
	в структуру добавлено логическое поле merge.

	Работа по поиску дубликатов файлов и ресурсов и выравниванию
	ресурсов при их добавлении перенесена в функции unpack, pack,
	print. Поиск и слияние дубликатов выполняется лишь в том случае,
	если поле merge структуры plugin_t истинно.

	Написал функцию сравнения данных в кольцевых буферах ringcmp,
	с её использованием написал функцию поиска наилучшего совпадения
	блоков данных для алгоритмов группы LZ77. Всё это находится
	в модуле ring.c

	Написал новую функцию, более ресурсоёмкую, но и более систематичную:
		bool_t dat_read_dir(restable_t *rt);

	Написал функцию dat_to_rt и функцию dat_from_rt. Вторая уже достаточна
	для написания правильной функции dat_prepare_dir, но перед записью
	заголовка DAT, я хочу отсортировать пути и имена файлов по алфавиту.

15-10-2010

	Написал функции для сортировки структуры dat_t - dat_sort, для
	подсчёта размера записываемого в DAT-файл каталога - dat_prepare_dir,
	и для записи каталога в DAT-файл - dat_write_dir.

	Написал функцию dat_decmpress, поместил её в модуль dat_lzss.c
	Сжатие ресурсов пока не поддерживается.

	Отладка не удалась - Fallout не работает с собранными мной файлами.
	Fallout показывает экран "подождите" и завершает работу.

16-10-2010

	Протестировал модуль dat.c. Не без проблем, но удалось довести его
	до рабочего состояния. Основная закавыка оказалас в том, что если
	имена каталогов и ресурсов записаны в верхнем регистре. Если имена
	каталогов и ресурсов записать в нижнем регистре, то Fallout запускается
	как ни в чём не бывало, хотя в файлах из дистрибутива игры все имена
	каталогов и ресурсов записаны в верхнем регистре. Объяснений этому не
	нахожу.

17-10-2010

	Переписал функции freadf и fwritef, а так же все остальные, на которых
	они основаны. Новые функции называются readf и writef. Форматная строка
	стала более фичастой, сами функции более прямыми.

	Например, функция readsz, замена функции s_freadz, теперь читает файл
	по порядку и не возвращается к уже прочитанному, по ходу чтения изменяя
	размер буфера бод строку. То есть теперь она пригодна для чтения файлов
	со строго последовательным доступом.

	Другой пример - вместо функций frwite_zeros и fread_bytes теперь
	используются fwritec и freadc, которые при передачи нулевого указателя
	на буфер чтения/записи записывают нули или читают данные "в пустоту".

	В функциях readf и writef введены спецификаторы длины аргумента
	n и N. Первое - число с длиной, второе - указатель на число с длиной.

19-10-2010

	Написал модуль binup.c - binary unpack/pack, в котором реализовал
	аналоги функций из модуля binrw2.c, только эти функции называются
	pack/unpack и работают с буфером памяти, а не файлом.

	Модуль rff.c был переписан с ипользованием binup.c. Его код
	стал значительно меньше, чище и нагляднее. Следующий
	запланированный ход - написание модуля text.c для парсинга
	текстовых файлов, чтобы восстанавливать значение поля type из
	текстового файла.	

	Затем модули binrw.c, binrw2.c и binup.c были объединены в один
	большой модуль bin.c

20-10-10

	Добавил в модуль bin.c функции scans и strtrim.

	Написал модуль meta.c для загрузки и сохранения метаданных.

	Добавил в модуль main.c режимы --savemeta и --loadmeta,
	к режимам --pack и --unpack добавил опцию --meta.

	Протестировал написанный функционал на файле blood.rff, вроде
	работает. Надо проверить на самой игре.

	Написанный код довольно грязный и нуждается в проверке.

	Переписал также функции s_name и компанию с использованием
	функции strrchr. Пока не тестировал - положил в модуль newnpe.c

	Blood с файлом, собранным моей программой, не запускается.

21-10-10

	Написал простейшую заготовку для модуля ipwad.c. Никакой попытки
	конвертировать имена ресурсов пока не делал.

22-10-10

	Наконец-таки написал модуль ipwad.c. То ли мозги работать лучше
	начали, то-ли помогли прошлые наработки, но моудль я дописал
	до рабочего состояния сегодня до конца. Модуль получился довольно
	грязным, но рабочим.

	Интересно, что в оригинальном файле doom.wad несколько раз
	встречаются ресурсы с одинаковыми именами. Пока что мне такие
	фокусы попадались только в RES-файле Commanche 3.

	Список файлов с одинаковыми именами:
		dpbarexp
		dpbdcls
		dpbdopn
		dpbgact
		dpbgdth1
		dpbgdth2
		dpbgsit1
		dpbgsit2
		dpbrsdth
		dpbrssit
		dpclaw
		dpdmact
		dpdmpain
		dpdorcls
		dpdoropn
		dpfirsht
		dpfirxpl
		dpgetpow
		dpitemup
		dpitmbk
		dpnoway
		dpoof
		dppdiehi
		dppistol
		dppldeth
		dpplpain
		dppodth1
		dppodth2
		dppodth3
		dppopain
		dpposact
		dpposit1
		dpposit2
		dpposit3
		dppstart
		dppstop
		dppunch
		dprlaunc
		dprxplod
		dpsawful
		dpsawhit
		dpsawidl
		dpsawup
		dpsgcock
		dpsgtatk
		dpsgtdth
		dpsgtsit
		dpshotgn
		dpslop
		dpstnmov
		dpswtchn
		dpswtchx
		dptelept
		dptink
		dpwpnup
		dsbarexp
		dsbdcls
		dsbdopn
		dsbgact
		dsbgdth1
		dsbgdth2
		dsbgsit1
		dsbgsit2
		dsbrsdth
		dsbrssit
		dsclaw
		dsdmact
		dsdmpain
		dsdorcls
		dsdoropn
		dsfirsht
		dsfirxpl
		dsgetpow
		dsitemup
		dsitmbk
		dsnoway
		dsoof
		dspdiehi
		dspistol
		dspldeth
		dsplpain
		dspodth1
		dspodth2
		dspodth3
		dspopain
		dsposact
		dsposit1
		dsposit2
		dsposit3
		dspstart
		dspstop
		dspunch
		dsrlaunc
		dsrxplod
		dssawful
		dssawhit
		dssawidl
		dssawup
		dssgcock
		dssgtatk
		dssgtdth
		dssgtsit
		dsshotgn
		dsslop
		dsstnmov
		dsswtchn
		dsswtchx
		dstelept
		dstink
		dswpnup

	Это наталкивает на мысль попытаться сделать функцию поиска
	дублей имён ресурсов.

09-11-2010

	Добавил в модуль rff.c отображение отметки времени ресурса.

13-11-2010

	Добавил в структуру плагина булевы поля meta и time,
	функции save_meta и load_meta.

	Переделал функции unpack, pack, print, savemeta с учётом
	функционала плагинов для загрузки и сохранения метаданных.
	Удалил функцию loadmeta.

	Реализовал функции для переноса времени модификации файла
	из файла-пачки на файл и из файла в файл-пачку:
	rt_get_timestamp и rt_set_timestamp

	Проверил перенос отметок времени на примере rff-файла.

29-12-2010

	Адаптировал утилиту lzss.c от Haruhiko Okumura в модуль
	lzss.c.

	Переделал модуль pack2_lz.c в модуль c_pack2.c, создал
	модули c_zlib.c, c_lzss.c. Суть переделки состоит в том,
	что теперь все функции компрессии/декомпрессии приведены
	к единому интерфейсу:
		size_t dsize(size_t ssize);

		bool_t compress(unsigned char *s, size_t ssize, unsigned char *d, size_t *dsize, int level);
		или
		bool_t compress(unsigned char *s, size_t ssize, unsigned char *d, size_t *dsize);

		bool_t decompress(unsigned char *s, size_t ssize, unsigned char *d, size_t dsize);

	Написал модуль c_dat.c с использованием c_lzss.c. Протестировал - работает.

11-01-2011

	В заголовке формата RFF, в поле версии младшие два байта во всех исследованных
	мной образцах файлов принимают следующие значения:
	2 и 0 - формат условно названный ранее Plain RFF,
	3 и 1 - формат условно названный ранее Crypted RFF,
	3 и 0 - формат, создаваемый одной из доступных версий программы BARF.
	
	В соответствии с этим, я назвал эти форматы rff20, rff30, rff31.
	
	Сегодня я добавил поддержку формата rff30, который отличался от rff31
	только способом шифрования каталога и соответствующим образом
	переименовал все модули.

17-01-2011

	Доделал загрузку метаданных. Обнаружил, что в blood.rff есть ресурсы с
	одинаковыми именами:
		BAT1D1.SEQ
		BEST1D1.SEQ
		BEST2D1.SEQ
		CERB1E1.SEQ
		CULT1D3B.SEQ
		CULT2E1.SEQ
		GOST1M1.SEQ
		HAND1D1.SEQ
		PLAY1D1.SEQ
		PLAY1M1.SEQ
		PLAY1M4.SEQ
		POD1CLOS.SEQ
		POD2CLOS.SEQ
		PRIS1D1.SEQ
		RAT1D1.SEQ
		SPID3A2.SEQ
		SPID3D1.SEQ
		SPID3D2.SEQ
		SPID3D3.SEQ
		SPID3I1.SEQ
		SPID3M1.SEQ
		SPID3M2.SEQ
		TBOG1D1.SEQ
		TENT1D2.SEQ
		TENT1DOW.SEQ
		TENT2D2.SEQ
		TENT2DOW.SEQ

18-01-2011

	Написал функции s_sprintf, rt_rename, is_equal_blocks для того, чтобы на их базе
	в дальнейшем организовать корректную обработку ресурсов с одинаковыми именами.

	Переименовал функции strupper, strlower, strnupper, strnlower соответственно в
	s_strupper, s_strlower, s_strnupper, s_strnlower.

19-01-2011

	Добавил функцию s_let, переделал функции s_strcpy, s_strncpy, s_strcat, s_strncat
	в функции sn_strcpy, sn_strncpy, sn_strcat, sn_strncat.

	На основе s_let и sn_strcpy, sn_strncpy, sn_strcat, sn_strncat реализовал старые
	функции s_strcpy, s_strncpy, s_strcat, s_strncat.

	Переделал функцию s_sprintf в функцию snv_sprintf.

	На основе s_let и snv_sprintf реализовал функцию s_sprintf.

	Добавил два регресионных теста для функции s_sprintf. Все переделанные функции
	успешно прошли процедуру регресионного тестирования.

27-01-2011

	Переделал функции s_uppath, s_path, s_pathname, s_name, s_nameext, s_ext в
	функции sn_uppath, sn_path, sn_pathname, sn_name, sn_nameext, sn_ext.

	На основе s_let и sn_uppath, sn_path, sn_pathname, sn_name, sn_nameext, sn_ext
	реализовал функции s_uppath, s_path, s_pathname, s_name, s_nameext, s_ext.

	Регрессионные тесты завершились успешно.

01-02-2011

	Написал и почти отладил функцию rt_fix_loaded, которая должна заниматься
	поиском дублей, поиском ссылок на одинаковые блоки, поиском пересечений
	блоков, а также поиском одинаковых имён файлов.

	Переписал функцию проверки каталога rt_fix взамен rt_fix_loaded. Сделал
	по принципу чем проще, тем лучше. Действительно получилось лучше - объём
	меньше, сложность ниже, скорость работы на глаз не изменилась.

	Провёл чистку: удалил rt_fix_loaded, rt_search_overlaps, rt_search_doubles,
	rt_sort и т.п. Объём проекта после чистки вновь стал меньше 10000 строк.

	Протестировал разборку и сборку blood.rff, собирается файл того же размера.
	Количество и порядок ресурсов сохраняется.

09-02-2011

	В алгоритме сжатия pack2 управляющий байт со значением 0xFF используется
	в качестве индикатора конца сжатого потока. Некоторое время назад я
	соответствующим образом исправил декодировщик, а сегодня исправил
	кодировщик.

	Объединил все функции *_fadd и *_fextract в функции c_fadd и c_fextract.

	Появилась мысль немного поменять логику. c_fadd в случае если данные не
	были сжаты, должна возвращать сжатый размер равный нулю, а не равный
	несжатому размеру. Сделал.

08-11-2011

        Анализ соответствий типа записи и расширения в RFF-файле:

	type    ext

	0       MNU                     0       0000
	1       TXT, SFX, MID           1       0001
	16      MAP, RAW, TMB           0 + 16  0000
	17      WAV, KVX, QAV           1 + 16  0001 Прочие QAV
	20      QBM, QFN                4 + 16  0100
	21      SEQ                     5 + 16  0101
	24      FLU, TLU, DAT, CLU      8 + 16  1000
	25      PLU, PAL, QAV           9 + 16  1001 Экранный QAV

11-01-2013

	На компьютере нашёл все каталоги pup и выполнил сравнение. В результате
        осталось два разных каталога. В обоих каталогах программа не собиралась.
        Исправил программу в этом каталоге и собрал её.

        При изучении исходников был удивлён, что поддержка rff-файлов выполнена
        полностью. Потестировал на трёх rff31-файлах из blood: распаковал и
        запаковал обратно. Подменил собранные файлы в каталоге с игрой. Игра
        после замены продолжала работать.

        Из неоконченных функций остался, видимо, плагин поддержки IWAD/PWAD.
        Сомневаюсь, что смогу довести его до ума.
